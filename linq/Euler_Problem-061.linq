<Query Kind="Program" />

/*
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers 
are all figurate (polygonal) numbers and are generated by the following formulae:

~~~
Triangle        P3,n=n(n+1)/2    1, 3, 6, 10, 15, ...
Square          P4,n=n2          1, 4, 9, 16, 25, ...
Pentagonal      P5,n=n(3n−1)/2   1, 5, 12, 22, 35, ...
Hexagonal       P6,n=n(2n−1)     1, 6, 15, 28, 45, ...
Heptagonal      P7,n=n(5n−3)/2   1, 7, 18, 34, 55, ...
Octagonal       P8,n=n(3n−2)     1, 8, 21, 40, 65, ...
~~~

The ordered set of three 4-digit numbers: `8128, 2882, 8281`, has three interesting properties.

 - The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 - Each polygonal type: triangle (`P(3,127)=8128`), square (`P(4,91)=8281`), and pentagonal (`P(5,44)=2882`), is represented by a different number in the set.
 - This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, 
is represented by a different number in the set.
*/

// [0] Triangle 
// [1] Square
// [2] Pentagonal
// [3] Hexagonal
// [4] Heptagonal
// [5] Octagonal

const int SIDES_COUNT = 6;
bool DBG = false;

List<List<int>> cache = new List<List<int>>();


int P(int sides, int idx) {return (sides+1) * (idx*idx - idx)/2 + idx;}

bool digitMatch(int first, int second) { return (first%100) == (second/100); }


void Main()
{
	//####################
	//#    INITIALIZE    #
	//####################
	
	for(int i = 0; i < SIDES_COUNT; i++) cache.Add(new List<int>());
	
	for (int n = 0; n < SIDES_COUNT; n++)
	{
		var ls = cache[n];
		
		for(int idx = 1;;idx++)
		{
			int v = P(n, idx);
			
			if (v < 1000) continue;
			if (v > 9999) break;
			
			ls.Add(v);
		}
	}

	//####################
	//#      CHAIN       #
	//####################
	
	var found = new HashSet<string>();
	
	int max_idx = 127;//cache.Max(p => p.Count());
	
	int[] chain = new int[SIDES_COUNT];      	// index of polygon_number
	int[] used_sides = new int[SIDES_COUNT]; 	// index of used polygon (sides)
	bool[] used_polys = new bool[SIDES_COUNT];	// if polygon_number is used
	
	used_sides[0] = -1;
	chain[0] = 0;
	int chainpos = 0;
	
	while(chainpos >= 0)
	{
		++used_sides[chainpos];
		
		var curr_poly = used_sides[chainpos];
		var curr_idx = chain[chainpos];
		
		if (curr_poly == SIDES_COUNT)
		{
			used_sides[chainpos] = -1;
			chain[chainpos]++;
			
			if (DBG) "0".Dump();
			continue;
		}
		
		var curr_cache = cache[curr_poly];
		
		if (curr_idx > max_idx)
		{
			chainpos--;
			
			if (chainpos >= 0) used_polys[used_sides[chainpos]] = false;
			
			if (DBG) "1".Dump();
			continue;
		}
		
		if (used_polys[curr_poly])
		{
			if (DBG) "2".Dump();
			continue;
		}
		
		if (curr_idx > curr_cache.Count() - 1)
		{
			if (DBG) "3".Dump();
			continue;
		}
		
		var curr_number = curr_cache[curr_idx];
		
		if (chainpos != 0 && !digitMatch(cache[used_sides[chainpos-1]][chain[chainpos-1]], curr_number))
		{
			if (DBG) "4".Dump();
			continue;
		}
		
		if (chainpos < SIDES_COUNT-1)
		{
			used_polys[curr_poly] = true;
		
			chainpos++;
			used_sides[chainpos] = -1;
			chain[chainpos] = 0;
			
			if (DBG) "5".Dump();
			continue;
		}
			
		if (!digitMatch(curr_number, cache[used_sides[0]][chain[0]]))
		{
			if (DBG) "6".Dump();
			continue;
		}
		
		/**/ string hash = chain.Select((p, i) => cache[used_sides[i]][p]).OrderBy(p => p).Select(p => p.ToString()).Aggregate((a,b) => a+":"+b);
		/**/ if (found.Contains(hash)) continue;
		/**/ found.Add(hash);
		/**/ ("HASH := " + (uint)hash.GetHashCode() + "    (" + hash + ")").Dump();
		
		chain.Select((p,i) => new 
		{
			Idx=p, 
			Val=cache[used_sides[i]][p],
			Poly=used_sides[i]+3,
			Hits = string.Join("", cache.Select(k => k.Contains(cache[used_sides[i]][p]) ? "X":"-")),
		}).Dump();
	}
}